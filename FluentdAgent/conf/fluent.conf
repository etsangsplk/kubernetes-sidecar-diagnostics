# If LOG_FILE_PATH is not specified, the in_tail plugin will be removed
@include file.conf

<source>
  @type tail
  path "/var/log/containers/#{ENV['POD_NAME']}_#{ENV['NAMESPACE_NAME']}_#{ENV['SOURCE_CONTAINER_NAME']}-*.log"
  pos_file /var/fluentdsidecar/fluentd-console.log.pos
  time_format %Y-%m-%dT%H:%M:%S.%NZ
  tag kubernetes.console.*
  format json
  read_from_head true
</source>

<source>
  @type http
  port "#{ENV['APP_INSIGHTS_HTTP_CHANNEL_PORT']}"
  <parse>
    # Explicitly set the time_key to nil.
    # The reason is the http plugin will by default remove the "time" property from the record and parse it.
    # However, the default time type is float, seconds since epoch. While AI's time property is in iso8601 format, thus the parsing will fail. A new timestamp is assigned in this case, but we lost the original one.
    # We can also set the time_format to be %iso8601. But the drawback is if the time_format is specified explicitly but failed to parse, the whole record will be dropped without any logging.
    # Setting the time_key to nil so the time property is retained. Even if the time format is incorrect, it will be reported by the AI sdk.
    @type json
    time_key nil
  </parse>
</source>

# Only decorate kubernetes metadata that are actually coming from the app container.
# One counter example is fluentd will capture its own log, with tag as fluent.*.
# We don't want to decorate it with the app container's metadata since the log is from the sidecar container.
<match fluent.**>
  @type stdout
</match>

<filter **>
  @type kubernetes_metadata
  <metadata_source>
    namespace_name "#{ENV['NAMESPACE_NAME']}"
    pod_name "#{ENV['POD_NAME']}"
    container_name "#{ENV['SOURCE_CONTAINER_NAME']}"
  </metadata_source>
</filter>

# TODO: should we just try standard format anyways for console and http channel? And also set the message_property to "log" so we can merge the AI output?
# We may still need the default AI output since the message property of file input is "message", which is different from console input, where the message property is "log"
# Test the memory and cpu usage and make desicion!
<match kubernetes.console.**>
  @type application_insights
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  message_property log
  context_tag_sources {
    "ai.cloud.role": "$.kubernetes.container_name",
    "ai.cloud.roleInstance": "$.kubernetes.pod_name"
  }
</match>

<match ApplicationInsightsHttpChannel.**>
  @type application_insights
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  standard_schema true
  context_tag_sources {
    "ai.cloud.role": "$.kubernetes.container_name",
    "ai.cloud.roleInstance": "$.kubernetes.pod_name"
  }
</match>

<match **>
  @type application_insights
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  context_tag_sources {
    "ai.cloud.role": "$.kubernetes.container_name",
    "ai.cloud.roleInstance": "$.kubernetes.pod_name"
  }
</match>
