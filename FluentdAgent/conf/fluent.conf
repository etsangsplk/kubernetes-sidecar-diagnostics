# If LOG_FILE_PATH is not specified, the in_tail plugin will be removed
@include file.conf

<source>
  @type forward
</source>

<source>
  @type tail
  path "/var/log/containers/#{ENV['POD_NAME']}_#{ENV['NAMESPACE_NAME']}_#{ENV['SOURCE_CONTAINER_NAME']}-*.log"
  pos_file /var/fluentdsidecar/fluentd-containers.log.pos
  time_format %Y-%m-%dT%H:%M:%S.%NZ
  tag kubernetes.console.*
  format json
  read_from_head true
</source>

<source>
  @type http
  # The default port is 8888 which is also used by fiddler, so we choose port 8887 instead.
  # Should be configurable through k8s yaml and default to 8888 when productize.
  # Now that we use a custom parse configuration, we probably want to use a special port number.
  port 8887
  <parse>
    # The default time type is float, seconds since epoch. But AI's time property is in iso8601 format
    # TODO: consider set the time_key to nil instead of set the time_format. The drawback of time_format is if
    # the format doesn't match, the event will be dropped WITHOUT ANY LOGGING!. If set the format, it should at least report error if can't be parsed.
    @type json
    time_format %iso8601
  </parse>
</source>

# <source>
#   @type systemd
#   filters [{ "_SYSTEMD_UNIT": "kubelet.service" }]
#   pos_file /var/log/fluentd-journald-kubelet.pos
#   read_from_head true
#   tag kubelet
# </source>

# # Logs from systemd-journal for interesting services.
# <source>
#   @type systemd
#   filters [{ "_SYSTEMD_UNIT": "bootkube.service" }]
#   pos_file /var/log/fluentd-journald-bootkube.pos
#   read_from_head true
#   tag bootkube
# </source>

# Only decorate kubernetes metadata that are actually coming from the app container.
# One counter example is fluentd will capture its own log, with tag as fluent.*.
# We don't want to decorate it with the app container's metadata since the log is from the sidecar container.
<match fluent.**>
  @type stdout
</match>

<filter **>
  @type kubernetes_metadata_sidecar
  source_container_name "#{ENV['SOURCE_CONTAINER_NAME']}"
  pod_name "#{ENV['POD_NAME']}"
  namespace_name "#{ENV['NAMESPACE_NAME']}"
</filter>

<match kubernetes.console.**>
  @type application_insights
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  message_property log
  context_tag_sources {
    "ai.cloud.role": "$.kubernetes.container_name",
    "ai.cloud.roleInstance": "$.kubernetes.pod_name"
  }
</match>

<match ApplicationInsightsHttpChannel.**>
  @type application_insights
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  standard_schema true
  context_tag_sources {
    "ai.cloud.role": "$.kubernetes.container_name",
    "ai.cloud.roleInstance": "$.kubernetes.pod_name"
  }
</match>

<match **>
  @type application_insights
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
</match>
