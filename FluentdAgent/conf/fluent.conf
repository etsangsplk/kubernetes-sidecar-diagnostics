
# AUTOMATICALLY GENERATED
# DO NOT EDIT THIS FILE DIRECTLY, USE /templates/conf/fluent.conf.erb

<source>
  @type forward
</source>

# <source>
#   @type kubernetes_logs
#   container_name "#{ENV['SOURCE_CONTAINER_NAME']}"
#   tag kubernetes.console
# </source>

<source>
  @type http
  # The default port is 8888 which is also used by fiddler, so we choose port 8887 instead.
  # Should be configurable through k8s yaml and default to 8888 when productize.
  port 8887
</source>

# Only decorate kubernetes metadata that are actually comiing from the app container.
# One counter example is fluentd will capture its own log, with tag as fluent.*.
# We don't want to decorate it with the app container's metadata since the log is from the sidecar container.
<filter kubernetes.console ApplicationInsightsHttpChannel.**>
  @type kubernetes_metadata_sidecar
  source_container_name "#{ENV['SOURCE_CONTAINER_NAME']}"
  pod_name "#{ENV['POD_NAME']}"
  namespace_name "#{ENV['NAMESPACE_NAME']}"
</filter>

<filter kubernetes.console ApplicationInsightsHttpChannel.**>
  @type application_insights_cloud_context
  # For testing purpose, use role_name_property here, although we can use role_name directly
  role_name_property kubernetes.container_name
  role_instance_property kubernetes.pod_name
  force true
</filter>

<match fluent.**>
  @type stdout
</match>

<match kubernetes.console>
  @type application_insights
  developer_mode true
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  message_property log
</match>

<match ApplicationInsightsHttpChannel.**>
  @type application_insights
  developer_mode true
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
  standard_schema true
</match>

<match **>
  @type application_insights
  developer_mode true
  instrumentation_key "#{ENV['INSTRUMENTATION_KEY']}"
</match>
